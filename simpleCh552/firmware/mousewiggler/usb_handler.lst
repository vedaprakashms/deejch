                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler
                                      3 ; Version 4.5.0 #15242 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module usb_handler
                                      6 	
                                      7 	.optsdcc -mmcs51 --model-small
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _USB_EP0_OUT
                                     12 	.globl _USB_EP0_IN
                                     13 	.globl _USB_EP0_SETUP
                                     14 	.globl _USB_EP0_copyDescr
                                     15 	.globl _HID_EP1_IN
                                     16 	.globl _HID_reset
                                     17 	.globl _HID_setup
                                     18 	.globl _UIF_BUS_RST
                                     19 	.globl _UIF_DETECT
                                     20 	.globl _UIF_TRANSFER
                                     21 	.globl _UIF_SUSPEND
                                     22 	.globl _UIF_HST_SOF
                                     23 	.globl _UIF_FIFO_OV
                                     24 	.globl _U_SIE_FREE
                                     25 	.globl _U_TOG_OK
                                     26 	.globl _U_IS_NAK
                                     27 	.globl _ADC_CHAN0
                                     28 	.globl _ADC_CHAN1
                                     29 	.globl _CMP_CHAN
                                     30 	.globl _ADC_START
                                     31 	.globl _ADC_IF
                                     32 	.globl _CMP_IF
                                     33 	.globl _CMPO
                                     34 	.globl _U1RI
                                     35 	.globl _U1TI
                                     36 	.globl _U1RB8
                                     37 	.globl _U1TB8
                                     38 	.globl _U1REN
                                     39 	.globl _U1SMOD
                                     40 	.globl _U1SM0
                                     41 	.globl _S0_R_FIFO
                                     42 	.globl _S0_T_FIFO
                                     43 	.globl _S0_FREE
                                     44 	.globl _S0_IF_BYTE
                                     45 	.globl _S0_IF_FIRST
                                     46 	.globl _S0_IF_OV
                                     47 	.globl _S0_FST_ACT
                                     48 	.globl _CP_RL2
                                     49 	.globl _C_T2
                                     50 	.globl _TR2
                                     51 	.globl _EXEN2
                                     52 	.globl _TCLK
                                     53 	.globl _RCLK
                                     54 	.globl _EXF2
                                     55 	.globl _CAP1F
                                     56 	.globl _TF2
                                     57 	.globl _RI
                                     58 	.globl _TI
                                     59 	.globl _RB8
                                     60 	.globl _TB8
                                     61 	.globl _REN
                                     62 	.globl _SM2
                                     63 	.globl _SM1
                                     64 	.globl _SM0
                                     65 	.globl _IT0
                                     66 	.globl _IE0
                                     67 	.globl _IT1
                                     68 	.globl _IE1
                                     69 	.globl _TR0
                                     70 	.globl _TF0
                                     71 	.globl _TR1
                                     72 	.globl _TF1
                                     73 	.globl _RXD
                                     74 	.globl _PWM1_
                                     75 	.globl _TXD
                                     76 	.globl _PWM2_
                                     77 	.globl _AIN3
                                     78 	.globl _VBUS1
                                     79 	.globl _INT0
                                     80 	.globl _TXD1_
                                     81 	.globl _INT1
                                     82 	.globl _T0
                                     83 	.globl _RXD1_
                                     84 	.globl _PWM2
                                     85 	.globl _T1
                                     86 	.globl _UDP
                                     87 	.globl _UDM
                                     88 	.globl _TIN0
                                     89 	.globl _CAP1
                                     90 	.globl _T2
                                     91 	.globl _AIN0
                                     92 	.globl _VBUS2
                                     93 	.globl _TIN1
                                     94 	.globl _CAP2
                                     95 	.globl _T2EX
                                     96 	.globl _RXD_
                                     97 	.globl _TXD_
                                     98 	.globl _AIN1
                                     99 	.globl _UCC1
                                    100 	.globl _TIN2
                                    101 	.globl _SCS
                                    102 	.globl _CAP1_
                                    103 	.globl _T2_
                                    104 	.globl _AIN2
                                    105 	.globl _UCC2
                                    106 	.globl _TIN3
                                    107 	.globl _PWM1
                                    108 	.globl _MOSI
                                    109 	.globl _TIN4
                                    110 	.globl _RXD1
                                    111 	.globl _MISO
                                    112 	.globl _TIN5
                                    113 	.globl _TXD1
                                    114 	.globl _SCK
                                    115 	.globl _IE_SPI0
                                    116 	.globl _IE_TKEY
                                    117 	.globl _IE_USB
                                    118 	.globl _IE_ADC
                                    119 	.globl _IE_UART1
                                    120 	.globl _IE_PWMX
                                    121 	.globl _IE_GPIO
                                    122 	.globl _IE_WDOG
                                    123 	.globl _PX0
                                    124 	.globl _PT0
                                    125 	.globl _PX1
                                    126 	.globl _PT1
                                    127 	.globl _PS
                                    128 	.globl _PT2
                                    129 	.globl _PL_FLAG
                                    130 	.globl _PH_FLAG
                                    131 	.globl _EX0
                                    132 	.globl _ET0
                                    133 	.globl _EX1
                                    134 	.globl _ET1
                                    135 	.globl _ES
                                    136 	.globl _ET2
                                    137 	.globl _E_DIS
                                    138 	.globl _EA
                                    139 	.globl _P
                                    140 	.globl _F1
                                    141 	.globl _OV
                                    142 	.globl _RS0
                                    143 	.globl _RS1
                                    144 	.globl _F0
                                    145 	.globl _AC
                                    146 	.globl _CY
                                    147 	.globl _UEP1_DMA_H
                                    148 	.globl _UEP1_DMA_L
                                    149 	.globl _UEP1_DMA
                                    150 	.globl _UEP0_DMA_H
                                    151 	.globl _UEP0_DMA_L
                                    152 	.globl _UEP0_DMA
                                    153 	.globl _UEP2_3_MOD
                                    154 	.globl _UEP4_1_MOD
                                    155 	.globl _UEP3_DMA_H
                                    156 	.globl _UEP3_DMA_L
                                    157 	.globl _UEP3_DMA
                                    158 	.globl _UEP2_DMA_H
                                    159 	.globl _UEP2_DMA_L
                                    160 	.globl _UEP2_DMA
                                    161 	.globl _USB_DEV_AD
                                    162 	.globl _USB_CTRL
                                    163 	.globl _USB_INT_EN
                                    164 	.globl _UEP4_T_LEN
                                    165 	.globl _UEP4_CTRL
                                    166 	.globl _UEP0_T_LEN
                                    167 	.globl _UEP0_CTRL
                                    168 	.globl _USB_RX_LEN
                                    169 	.globl _USB_MIS_ST
                                    170 	.globl _USB_INT_ST
                                    171 	.globl _USB_INT_FG
                                    172 	.globl _UEP3_T_LEN
                                    173 	.globl _UEP3_CTRL
                                    174 	.globl _UEP2_T_LEN
                                    175 	.globl _UEP2_CTRL
                                    176 	.globl _UEP1_T_LEN
                                    177 	.globl _UEP1_CTRL
                                    178 	.globl _UDEV_CTRL
                                    179 	.globl _USB_C_CTRL
                                    180 	.globl _TKEY_DATH
                                    181 	.globl _TKEY_DATL
                                    182 	.globl _TKEY_DAT
                                    183 	.globl _TKEY_CTRL
                                    184 	.globl _ADC_DATA
                                    185 	.globl _ADC_CFG
                                    186 	.globl _ADC_CTRL
                                    187 	.globl _SBAUD1
                                    188 	.globl _SBUF1
                                    189 	.globl _SCON1
                                    190 	.globl _SPI0_SETUP
                                    191 	.globl _SPI0_CK_SE
                                    192 	.globl _SPI0_CTRL
                                    193 	.globl _SPI0_DATA
                                    194 	.globl _SPI0_STAT
                                    195 	.globl _PWM_CK_SE
                                    196 	.globl _PWM_CTRL
                                    197 	.globl _PWM_DATA1
                                    198 	.globl _PWM_DATA2
                                    199 	.globl _T2CAP1H
                                    200 	.globl _T2CAP1L
                                    201 	.globl _T2CAP1
                                    202 	.globl _TH2
                                    203 	.globl _TL2
                                    204 	.globl _T2COUNT
                                    205 	.globl _RCAP2H
                                    206 	.globl _RCAP2L
                                    207 	.globl _RCAP2
                                    208 	.globl _T2MOD
                                    209 	.globl _T2CON
                                    210 	.globl _SBUF
                                    211 	.globl _SCON
                                    212 	.globl _TH1
                                    213 	.globl _TH0
                                    214 	.globl _TL1
                                    215 	.globl _TL0
                                    216 	.globl _TMOD
                                    217 	.globl _TCON
                                    218 	.globl _XBUS_AUX
                                    219 	.globl _PIN_FUNC
                                    220 	.globl _P3_DIR_PU
                                    221 	.globl _P3_MOD_OC
                                    222 	.globl _P3
                                    223 	.globl _P2
                                    224 	.globl _P1_DIR_PU
                                    225 	.globl _P1_MOD_OC
                                    226 	.globl _P1
                                    227 	.globl _ROM_CTRL
                                    228 	.globl _ROM_DATA_H
                                    229 	.globl _ROM_DATA_L
                                    230 	.globl _ROM_DATA
                                    231 	.globl _ROM_ADDR_H
                                    232 	.globl _ROM_ADDR_L
                                    233 	.globl _ROM_ADDR
                                    234 	.globl _GPIO_IE
                                    235 	.globl _IP_EX
                                    236 	.globl _IE_EX
                                    237 	.globl _IP
                                    238 	.globl _IE
                                    239 	.globl _WDOG_COUNT
                                    240 	.globl _RESET_KEEP
                                    241 	.globl _WAKE_CTRL
                                    242 	.globl _CLOCK_CFG
                                    243 	.globl _PCON
                                    244 	.globl _GLOBAL_CFG
                                    245 	.globl _SAFE_MOD
                                    246 	.globl _DPH
                                    247 	.globl _DPL
                                    248 	.globl _SP
                                    249 	.globl _B
                                    250 	.globl _ACC
                                    251 	.globl _PSW
                                    252 	.globl _EP1_buffer
                                    253 	.globl _EP0_buffer
                                    254 	.globl _pDescr
                                    255 	.globl _UsbConfig
                                    256 	.globl _SetupReq
                                    257 	.globl _SetupLen
                                    258 	.globl _USB_interrupt
                                    259 	.globl _USB_init
                                    260 ;--------------------------------------------------------
                                    261 ; special function registers
                                    262 ;--------------------------------------------------------
                                    263 	.area RSEG    (ABS,DATA)
      000000                        264 	.org 0x0000
                           0000D0   265 _PSW	=	0x00d0
                           0000E0   266 _ACC	=	0x00e0
                           0000F0   267 _B	=	0x00f0
                           000081   268 _SP	=	0x0081
                           000082   269 _DPL	=	0x0082
                           000083   270 _DPH	=	0x0083
                           0000A1   271 _SAFE_MOD	=	0x00a1
                           0000B1   272 _GLOBAL_CFG	=	0x00b1
                           000087   273 _PCON	=	0x0087
                           0000B9   274 _CLOCK_CFG	=	0x00b9
                           0000A9   275 _WAKE_CTRL	=	0x00a9
                           0000FE   276 _RESET_KEEP	=	0x00fe
                           0000FF   277 _WDOG_COUNT	=	0x00ff
                           0000A8   278 _IE	=	0x00a8
                           0000B8   279 _IP	=	0x00b8
                           0000E8   280 _IE_EX	=	0x00e8
                           0000E9   281 _IP_EX	=	0x00e9
                           0000C7   282 _GPIO_IE	=	0x00c7
                           008584   283 _ROM_ADDR	=	0x8584
                           000084   284 _ROM_ADDR_L	=	0x0084
                           000085   285 _ROM_ADDR_H	=	0x0085
                           008F8E   286 _ROM_DATA	=	0x8f8e
                           00008E   287 _ROM_DATA_L	=	0x008e
                           00008F   288 _ROM_DATA_H	=	0x008f
                           000086   289 _ROM_CTRL	=	0x0086
                           000090   290 _P1	=	0x0090
                           000092   291 _P1_MOD_OC	=	0x0092
                           000093   292 _P1_DIR_PU	=	0x0093
                           0000A0   293 _P2	=	0x00a0
                           0000B0   294 _P3	=	0x00b0
                           000096   295 _P3_MOD_OC	=	0x0096
                           000097   296 _P3_DIR_PU	=	0x0097
                           0000C6   297 _PIN_FUNC	=	0x00c6
                           0000A2   298 _XBUS_AUX	=	0x00a2
                           000088   299 _TCON	=	0x0088
                           000089   300 _TMOD	=	0x0089
                           00008A   301 _TL0	=	0x008a
                           00008B   302 _TL1	=	0x008b
                           00008C   303 _TH0	=	0x008c
                           00008D   304 _TH1	=	0x008d
                           000098   305 _SCON	=	0x0098
                           000099   306 _SBUF	=	0x0099
                           0000C8   307 _T2CON	=	0x00c8
                           0000C9   308 _T2MOD	=	0x00c9
                           00CBCA   309 _RCAP2	=	0xcbca
                           0000CA   310 _RCAP2L	=	0x00ca
                           0000CB   311 _RCAP2H	=	0x00cb
                           00CDCC   312 _T2COUNT	=	0xcdcc
                           0000CC   313 _TL2	=	0x00cc
                           0000CD   314 _TH2	=	0x00cd
                           00CFCE   315 _T2CAP1	=	0xcfce
                           0000CE   316 _T2CAP1L	=	0x00ce
                           0000CF   317 _T2CAP1H	=	0x00cf
                           00009B   318 _PWM_DATA2	=	0x009b
                           00009C   319 _PWM_DATA1	=	0x009c
                           00009D   320 _PWM_CTRL	=	0x009d
                           00009E   321 _PWM_CK_SE	=	0x009e
                           0000F8   322 _SPI0_STAT	=	0x00f8
                           0000F9   323 _SPI0_DATA	=	0x00f9
                           0000FA   324 _SPI0_CTRL	=	0x00fa
                           0000FB   325 _SPI0_CK_SE	=	0x00fb
                           0000FC   326 _SPI0_SETUP	=	0x00fc
                           0000C0   327 _SCON1	=	0x00c0
                           0000C1   328 _SBUF1	=	0x00c1
                           0000C2   329 _SBAUD1	=	0x00c2
                           000080   330 _ADC_CTRL	=	0x0080
                           00009A   331 _ADC_CFG	=	0x009a
                           00009F   332 _ADC_DATA	=	0x009f
                           0000C3   333 _TKEY_CTRL	=	0x00c3
                           00C5C4   334 _TKEY_DAT	=	0xc5c4
                           0000C4   335 _TKEY_DATL	=	0x00c4
                           0000C5   336 _TKEY_DATH	=	0x00c5
                           000091   337 _USB_C_CTRL	=	0x0091
                           0000D1   338 _UDEV_CTRL	=	0x00d1
                           0000D2   339 _UEP1_CTRL	=	0x00d2
                           0000D3   340 _UEP1_T_LEN	=	0x00d3
                           0000D4   341 _UEP2_CTRL	=	0x00d4
                           0000D5   342 _UEP2_T_LEN	=	0x00d5
                           0000D6   343 _UEP3_CTRL	=	0x00d6
                           0000D7   344 _UEP3_T_LEN	=	0x00d7
                           0000D8   345 _USB_INT_FG	=	0x00d8
                           0000D9   346 _USB_INT_ST	=	0x00d9
                           0000DA   347 _USB_MIS_ST	=	0x00da
                           0000DB   348 _USB_RX_LEN	=	0x00db
                           0000DC   349 _UEP0_CTRL	=	0x00dc
                           0000DD   350 _UEP0_T_LEN	=	0x00dd
                           0000DE   351 _UEP4_CTRL	=	0x00de
                           0000DF   352 _UEP4_T_LEN	=	0x00df
                           0000E1   353 _USB_INT_EN	=	0x00e1
                           0000E2   354 _USB_CTRL	=	0x00e2
                           0000E3   355 _USB_DEV_AD	=	0x00e3
                           00E5E4   356 _UEP2_DMA	=	0xe5e4
                           0000E4   357 _UEP2_DMA_L	=	0x00e4
                           0000E5   358 _UEP2_DMA_H	=	0x00e5
                           00E7E6   359 _UEP3_DMA	=	0xe7e6
                           0000E6   360 _UEP3_DMA_L	=	0x00e6
                           0000E7   361 _UEP3_DMA_H	=	0x00e7
                           0000EA   362 _UEP4_1_MOD	=	0x00ea
                           0000EB   363 _UEP2_3_MOD	=	0x00eb
                           00EDEC   364 _UEP0_DMA	=	0xedec
                           0000EC   365 _UEP0_DMA_L	=	0x00ec
                           0000ED   366 _UEP0_DMA_H	=	0x00ed
                           00EFEE   367 _UEP1_DMA	=	0xefee
                           0000EE   368 _UEP1_DMA_L	=	0x00ee
                           0000EF   369 _UEP1_DMA_H	=	0x00ef
                                    370 ;--------------------------------------------------------
                                    371 ; special function bits
                                    372 ;--------------------------------------------------------
                                    373 	.area RSEG    (ABS,DATA)
      000000                        374 	.org 0x0000
                           0000D7   375 _CY	=	0x00d7
                           0000D6   376 _AC	=	0x00d6
                           0000D5   377 _F0	=	0x00d5
                           0000D4   378 _RS1	=	0x00d4
                           0000D3   379 _RS0	=	0x00d3
                           0000D2   380 _OV	=	0x00d2
                           0000D1   381 _F1	=	0x00d1
                           0000D0   382 _P	=	0x00d0
                           0000AF   383 _EA	=	0x00af
                           0000AE   384 _E_DIS	=	0x00ae
                           0000AD   385 _ET2	=	0x00ad
                           0000AC   386 _ES	=	0x00ac
                           0000AB   387 _ET1	=	0x00ab
                           0000AA   388 _EX1	=	0x00aa
                           0000A9   389 _ET0	=	0x00a9
                           0000A8   390 _EX0	=	0x00a8
                           0000BF   391 _PH_FLAG	=	0x00bf
                           0000BE   392 _PL_FLAG	=	0x00be
                           0000BD   393 _PT2	=	0x00bd
                           0000BC   394 _PS	=	0x00bc
                           0000BB   395 _PT1	=	0x00bb
                           0000BA   396 _PX1	=	0x00ba
                           0000B9   397 _PT0	=	0x00b9
                           0000B8   398 _PX0	=	0x00b8
                           0000EF   399 _IE_WDOG	=	0x00ef
                           0000EE   400 _IE_GPIO	=	0x00ee
                           0000ED   401 _IE_PWMX	=	0x00ed
                           0000EC   402 _IE_UART1	=	0x00ec
                           0000EB   403 _IE_ADC	=	0x00eb
                           0000EA   404 _IE_USB	=	0x00ea
                           0000E9   405 _IE_TKEY	=	0x00e9
                           0000E8   406 _IE_SPI0	=	0x00e8
                           000097   407 _SCK	=	0x0097
                           000097   408 _TXD1	=	0x0097
                           000097   409 _TIN5	=	0x0097
                           000096   410 _MISO	=	0x0096
                           000096   411 _RXD1	=	0x0096
                           000096   412 _TIN4	=	0x0096
                           000095   413 _MOSI	=	0x0095
                           000095   414 _PWM1	=	0x0095
                           000095   415 _TIN3	=	0x0095
                           000095   416 _UCC2	=	0x0095
                           000095   417 _AIN2	=	0x0095
                           000094   418 _T2_	=	0x0094
                           000094   419 _CAP1_	=	0x0094
                           000094   420 _SCS	=	0x0094
                           000094   421 _TIN2	=	0x0094
                           000094   422 _UCC1	=	0x0094
                           000094   423 _AIN1	=	0x0094
                           000093   424 _TXD_	=	0x0093
                           000092   425 _RXD_	=	0x0092
                           000091   426 _T2EX	=	0x0091
                           000091   427 _CAP2	=	0x0091
                           000091   428 _TIN1	=	0x0091
                           000091   429 _VBUS2	=	0x0091
                           000091   430 _AIN0	=	0x0091
                           000090   431 _T2	=	0x0090
                           000090   432 _CAP1	=	0x0090
                           000090   433 _TIN0	=	0x0090
                           0000B7   434 _UDM	=	0x00b7
                           0000B6   435 _UDP	=	0x00b6
                           0000B5   436 _T1	=	0x00b5
                           0000B4   437 _PWM2	=	0x00b4
                           0000B4   438 _RXD1_	=	0x00b4
                           0000B4   439 _T0	=	0x00b4
                           0000B3   440 _INT1	=	0x00b3
                           0000B2   441 _TXD1_	=	0x00b2
                           0000B2   442 _INT0	=	0x00b2
                           0000B2   443 _VBUS1	=	0x00b2
                           0000B2   444 _AIN3	=	0x00b2
                           0000B1   445 _PWM2_	=	0x00b1
                           0000B1   446 _TXD	=	0x00b1
                           0000B0   447 _PWM1_	=	0x00b0
                           0000B0   448 _RXD	=	0x00b0
                           00008F   449 _TF1	=	0x008f
                           00008E   450 _TR1	=	0x008e
                           00008D   451 _TF0	=	0x008d
                           00008C   452 _TR0	=	0x008c
                           00008B   453 _IE1	=	0x008b
                           00008A   454 _IT1	=	0x008a
                           000089   455 _IE0	=	0x0089
                           000088   456 _IT0	=	0x0088
                           00009F   457 _SM0	=	0x009f
                           00009E   458 _SM1	=	0x009e
                           00009D   459 _SM2	=	0x009d
                           00009C   460 _REN	=	0x009c
                           00009B   461 _TB8	=	0x009b
                           00009A   462 _RB8	=	0x009a
                           000099   463 _TI	=	0x0099
                           000098   464 _RI	=	0x0098
                           0000CF   465 _TF2	=	0x00cf
                           0000CF   466 _CAP1F	=	0x00cf
                           0000CE   467 _EXF2	=	0x00ce
                           0000CD   468 _RCLK	=	0x00cd
                           0000CC   469 _TCLK	=	0x00cc
                           0000CB   470 _EXEN2	=	0x00cb
                           0000CA   471 _TR2	=	0x00ca
                           0000C9   472 _C_T2	=	0x00c9
                           0000C8   473 _CP_RL2	=	0x00c8
                           0000FF   474 _S0_FST_ACT	=	0x00ff
                           0000FE   475 _S0_IF_OV	=	0x00fe
                           0000FD   476 _S0_IF_FIRST	=	0x00fd
                           0000FC   477 _S0_IF_BYTE	=	0x00fc
                           0000FB   478 _S0_FREE	=	0x00fb
                           0000FA   479 _S0_T_FIFO	=	0x00fa
                           0000F8   480 _S0_R_FIFO	=	0x00f8
                           0000C7   481 _U1SM0	=	0x00c7
                           0000C5   482 _U1SMOD	=	0x00c5
                           0000C4   483 _U1REN	=	0x00c4
                           0000C3   484 _U1TB8	=	0x00c3
                           0000C2   485 _U1RB8	=	0x00c2
                           0000C1   486 _U1TI	=	0x00c1
                           0000C0   487 _U1RI	=	0x00c0
                           000087   488 _CMPO	=	0x0087
                           000086   489 _CMP_IF	=	0x0086
                           000085   490 _ADC_IF	=	0x0085
                           000084   491 _ADC_START	=	0x0084
                           000083   492 _CMP_CHAN	=	0x0083
                           000081   493 _ADC_CHAN1	=	0x0081
                           000080   494 _ADC_CHAN0	=	0x0080
                           0000DF   495 _U_IS_NAK	=	0x00df
                           0000DE   496 _U_TOG_OK	=	0x00de
                           0000DD   497 _U_SIE_FREE	=	0x00dd
                           0000DC   498 _UIF_FIFO_OV	=	0x00dc
                           0000DB   499 _UIF_HST_SOF	=	0x00db
                           0000DA   500 _UIF_SUSPEND	=	0x00da
                           0000D9   501 _UIF_TRANSFER	=	0x00d9
                           0000D8   502 _UIF_DETECT	=	0x00d8
                           0000D8   503 _UIF_BUS_RST	=	0x00d8
                                    504 ;--------------------------------------------------------
                                    505 ; overlayable register banks
                                    506 ;--------------------------------------------------------
                                    507 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        508 	.ds 8
                                    509 ;--------------------------------------------------------
                                    510 ; internal ram data
                                    511 ;--------------------------------------------------------
                                    512 	.area DSEG    (DATA)
      000000                        513 _SetupLen::
      000000                        514 	.ds 2
      000002                        515 _SetupReq::
      000002                        516 	.ds 1
      000003                        517 _UsbConfig::
      000003                        518 	.ds 1
      000004                        519 _pDescr::
      000004                        520 	.ds 2
                                    521 ;--------------------------------------------------------
                                    522 ; overlayable items in internal ram
                                    523 ;--------------------------------------------------------
                                    524 	.area	OSEG    (OVR,DATA)
                                    525 ;--------------------------------------------------------
                                    526 ; indirectly addressable internal ram data
                                    527 ;--------------------------------------------------------
                                    528 	.area ISEG    (DATA)
                                    529 ;--------------------------------------------------------
                                    530 ; absolute internal ram data
                                    531 ;--------------------------------------------------------
                                    532 	.area IABS    (ABS,DATA)
                                    533 	.area IABS    (ABS,DATA)
                                    534 ;--------------------------------------------------------
                                    535 ; bit data
                                    536 ;--------------------------------------------------------
                                    537 	.area BSEG    (BIT)
      000000                        538 _USB_EP0_SETUP_sloc0_1_0:
      000000                        539 	.ds 1
      000001                        540 _USB_EP0_IN_sloc0_1_0:
      000001                        541 	.ds 1
                                    542 ;--------------------------------------------------------
                                    543 ; paged external ram data
                                    544 ;--------------------------------------------------------
                                    545 	.area PSEG    (PAG,XDATA)
                                    546 ;--------------------------------------------------------
                                    547 ; uninitialized external ram data
                                    548 ;--------------------------------------------------------
                                    549 	.area XSEG    (XDATA)
                           000000   550 _EP0_buffer	=	0x0000
                           00000A   551 _EP1_buffer	=	0x000a
                                    552 ;--------------------------------------------------------
                                    553 ; absolute external ram data
                                    554 ;--------------------------------------------------------
                                    555 	.area XABS    (ABS,XDATA)
                                    556 ;--------------------------------------------------------
                                    557 ; initialized external ram data
                                    558 ;--------------------------------------------------------
                                    559 	.area HOME    (CODE)
                                    560 	.area GSINIT0 (CODE)
                                    561 	.area GSINIT1 (CODE)
                                    562 	.area GSINIT2 (CODE)
                                    563 	.area GSINIT3 (CODE)
                                    564 	.area GSINIT4 (CODE)
                                    565 	.area GSINIT5 (CODE)
                                    566 	.area GSINIT  (CODE)
                                    567 	.area GSFINAL (CODE)
                                    568 	.area CSEG    (CODE)
                                    569 ;--------------------------------------------------------
                                    570 ; global & static initialisations
                                    571 ;--------------------------------------------------------
                                    572 	.area HOME    (CODE)
                                    573 	.area GSINIT  (CODE)
                                    574 	.area GSFINAL (CODE)
                                    575 	.area GSINIT  (CODE)
                                    576 ;--------------------------------------------------------
                                    577 ; Home
                                    578 ;--------------------------------------------------------
                                    579 	.area HOME    (CODE)
                                    580 	.area HOME    (CODE)
                                    581 ;--------------------------------------------------------
                                    582 ; code
                                    583 ;--------------------------------------------------------
                                    584 	.area CSEG    (CODE)
                                    585 ;------------------------------------------------------------
                                    586 ;Allocation info for local variables in function 'USB_EP0_copyDescr'
                                    587 ;------------------------------------------------------------
                                    588 ;len           Allocated to registers 
                                    589 ;------------------------------------------------------------
                                    590 ;	src/usb_handler.c:18: void USB_EP0_copyDescr(uint8_t len) {
                                    591 ;	-----------------------------------------
                                    592 ;	 function USB_EP0_copyDescr
                                    593 ;	-----------------------------------------
      000000                        594 _USB_EP0_copyDescr:
                           000007   595 	ar7 = 0x07
                           000006   596 	ar6 = 0x06
                           000005   597 	ar5 = 0x05
                           000004   598 	ar4 = 0x04
                           000003   599 	ar3 = 0x03
                           000002   600 	ar2 = 0x02
                           000001   601 	ar1 = 0x01
                           000000   602 	ar0 = 0x00
                                    603 ;	src/usb_handler.c:35: __endasm;
      000000 C0 07            [24]  604 	push	ar7 ; r7 -> stack
      000002 AF 82            [24]  605 	mov	r7, dpl ; r7 <- len
      000004 05 A2            [12]  606 	inc	_XBUS_AUX ; select dptr1
      000006 90 00 00         [24]  607 	mov	dptr, #_EP0_buffer ; dptr1 <- EP0_buffer
      000009 15 A2            [12]  608 	dec	_XBUS_AUX ; select dptr0
      00000B 85*04 82         [24]  609 	mov	dpl, _pDescr ; dptr0 <- *pDescr
      00000E 85*05 83         [24]  610 	mov	dph, (_pDescr + 1)
      000011                        611 01$:
      000011 E4               [12]  612 	clr	a ; acc <- #0
      000012 93               [24]  613 	movc	a, @a+dptr ; acc <- *pDescr[dptr0]
      000013 A3               [24]  614 	inc	dptr ; inc dptr0
      000014 A5                     615 	.DB	0xA5 ; acc -> EP0_buffer[dptr1] & inc dptr1
      000015 DF FA            [24]  616 	djnz	r7, 01$ ; repeat len times
      000017 D0 07            [24]  617 	pop	ar7 ; r7 <- stack
                                    618 ;	src/usb_handler.c:36: }
      000019 22               [24]  619 	ret
                                    620 ;------------------------------------------------------------
                                    621 ;Allocation info for local variables in function 'USB_EP0_SETUP'
                                    622 ;------------------------------------------------------------
                                    623 ;len           Allocated to registers r7 
                                    624 ;------------------------------------------------------------
                                    625 ;	src/usb_handler.c:42: void USB_EP0_SETUP(void) {
                                    626 ;	-----------------------------------------
                                    627 ;	 function USB_EP0_SETUP
                                    628 ;	-----------------------------------------
      00001A                        629 _USB_EP0_SETUP:
                                    630 ;	src/usb_handler.c:43: uint8_t len = USB_RX_LEN;
      00001A AF DB            [24]  631 	mov	r7,_USB_RX_LEN
                                    632 ;	src/usb_handler.c:44: if(len == (sizeof(USB_SETUP_REQ))) {
      00001C BF 08 02         [24]  633 	cjne	r7,#0x08,00374$
      00001F 80 03            [24]  634 	sjmp	00375$
      000021                        635 00374$:
      000021 02r02r9E         [24]  636 	ljmp	00173$
      000024                        637 00375$:
                                    638 ;	src/usb_handler.c:45: SetupLen = ((uint16_t)USB_setupBuf->wLengthH<<8) | (USB_setupBuf->wLengthL);
      000024 90 00 07         [24]  639 	mov	dptr,#(_EP0_buffer + 0x0007)
      000027 E0               [24]  640 	movx	a,@dptr
      000028 FE               [12]  641 	mov	r6,a
      000029 7F 00            [12]  642 	mov	r7,#0x00
      00002B 90 00 06         [24]  643 	mov	dptr,#(_EP0_buffer + 0x0006)
      00002E E0               [24]  644 	movx	a,@dptr
      00002F FD               [12]  645 	mov	r5,a
      000030 7C 00            [12]  646 	mov	r4,#0x00
      000032 4F               [12]  647 	orl	a,r7
      000033 F5*00            [12]  648 	mov	_SetupLen,a
      000035 EC               [12]  649 	mov	a,r4
      000036 4E               [12]  650 	orl	a,r6
      000037 F5*01            [12]  651 	mov	(_SetupLen + 1),a
                                    652 ;	src/usb_handler.c:46: len = 0;                                      // default is success and upload 0 length
                                    653 ;	src/usb_handler.c:47: SetupReq = USB_setupBuf->bRequest;
      000039 90 00 01         [24]  654 	mov	dptr,#(_EP0_buffer + 0x0001)
      00003C E0               [24]  655 	movx	a,@dptr
      00003D F5*02            [12]  656 	mov	_SetupReq,a
                                    657 ;	src/usb_handler.c:49: if( (USB_setupBuf->bRequestType & USB_REQ_TYP_MASK) != USB_REQ_TYP_STANDARD ) {
      00003F 90 00 00         [24]  658 	mov	dptr,#_EP0_buffer
      000042 E0               [24]  659 	movx	a,@dptr
      000043 FE               [12]  660 	mov	r6,a
      000044 54 60            [12]  661 	anl	a,#0x60
      000046 60 05            [24]  662 	jz	00170$
                                    663 ;	src/usb_handler.c:53: len = 0xFF;                                 // command not supported
      000048 7F FF            [12]  664 	mov	r7,#0xff
      00004A 02r02rA0         [24]  665 	ljmp	00174$
      00004D                        666 00170$:
                                    667 ;	src/usb_handler.c:58: switch(SetupReq) {                          // request ccfType
      00004D E5*02            [12]  668 	mov	a,_SetupReq
      00004F 24 F4            [12]  669 	add	a,#0xff - 0x0b
      000051 50 03            [24]  670 	jnc	00377$
      000053 02r02r9A         [24]  671 	ljmp	00167$
      000056                        672 00377$:
      000056 E5*02            [12]  673 	mov	a,_SetupReq
      000058 24 0B            [12]  674 	add	a,#(00378$-3-.)
      00005A 83               [24]  675 	movc	a,@a+pc
      00005B F5 82            [12]  676 	mov	dpl,a
      00005D E5*02            [12]  677 	mov	a,_SetupReq
      00005F 24 10            [12]  678 	add	a,#(00379$-3-.)
      000061 83               [24]  679 	movc	a,@a+pc
      000062 F5 83            [12]  680 	mov	dph,a
      000064 E4               [12]  681 	clr	a
      000065 73               [24]  682 	jmp	@a+dptr
      000066                        683 00378$:
      000066r7C                     684 	.db	00163$
      000067r9D                     685 	.db	00129$
      000068r9A                     686 	.db	00167$
      000069rFA                     687 	.db	00145$
      00006Ar9A                     688 	.db	00167$
      00006Br6D                     689 	.db	00122$
      00006Cr7E                     690 	.db	00101$
      00006Dr9A                     691 	.db	00167$
      00006Er79                     692 	.db	00123$
      00006Fr94                     693 	.db	00126$
      000070rA0                     694 	.db	00174$
      000071rA0                     695 	.db	00174$
      000072                        696 00379$:
      000072s02                     697 	.db	00163$>>8
      000073s01                     698 	.db	00129$>>8
      000074s02                     699 	.db	00167$>>8
      000075s01                     700 	.db	00145$>>8
      000076s02                     701 	.db	00167$>>8
      000077s01                     702 	.db	00122$>>8
      000078s00                     703 	.db	00101$>>8
      000079s02                     704 	.db	00167$>>8
      00007As01                     705 	.db	00123$>>8
      00007Bs01                     706 	.db	00126$>>8
      00007Cs02                     707 	.db	00174$>>8
      00007Ds02                     708 	.db	00174$>>8
                                    709 ;	src/usb_handler.c:59: case USB_GET_DESCRIPTOR:
      00007E                        710 00101$:
                                    711 ;	src/usb_handler.c:60: switch(USB_setupBuf->wValueH) {
      00007E 90 00 03         [24]  712 	mov	dptr,#(_EP0_buffer + 0x0003)
      000081 E0               [24]  713 	movx	a,@dptr
      000082 FE               [12]  714 	mov	r6,a
      000083 BE 01 02         [24]  715 	cjne	r6,#0x01,00380$
      000086 80 12            [24]  716 	sjmp	00102$
      000088                        717 00380$:
      000088 BE 02 02         [24]  718 	cjne	r6,#0x02,00381$
      00008B 80 17            [24]  719 	sjmp	00103$
      00008D                        720 00381$:
      00008D BE 03 02         [24]  721 	cjne	r6,#0x03,00382$
      000090 80 1C            [24]  722 	sjmp	00104$
      000092                        723 00382$:
      000092 BE 22 02         [24]  724 	cjne	r6,#0x22,00383$
      000095 80 69            [24]  725 	sjmp	00112$
      000097                        726 00383$:
      000097 02r01r18         [24]  727 	ljmp	00116$
                                    728 ;	src/usb_handler.c:62: case USB_DESCR_TYP_DEVICE:            // Device Descriptor
      00009A                        729 00102$:
                                    730 ;	src/usb_handler.c:63: pDescr = (uint8_t*)&DevDescr;       // put descriptor into out buffer
      00009A 75*04r00         [24]  731 	mov	_pDescr,#_DevDescr
      00009D 75*05s00         [24]  732 	mov	(_pDescr + 1),#(_DevDescr >> 8)
                                    733 ;	src/usb_handler.c:64: len = sizeof(DevDescr);             // descriptor length
      0000A0 7F 12            [12]  734 	mov	r7,#0x12
                                    735 ;	src/usb_handler.c:65: break;
                                    736 ;	src/usb_handler.c:67: case USB_DESCR_TYP_CONFIG:            // Configuration Descriptor
      0000A2 80 76            [24]  737 	sjmp	00117$
      0000A4                        738 00103$:
                                    739 ;	src/usb_handler.c:68: pDescr = (uint8_t*)&CfgDescr;       // put descriptor into out buffer
      0000A4 75*04r00         [24]  740 	mov	_pDescr,#_CfgDescr
      0000A7 75*05s00         [24]  741 	mov	(_pDescr + 1),#(_CfgDescr >> 8)
                                    742 ;	src/usb_handler.c:69: len = sizeof(CfgDescr);             // descriptor length
      0000AA 7F 22            [12]  743 	mov	r7,#0x22
                                    744 ;	src/usb_handler.c:70: break;
                                    745 ;	src/usb_handler.c:72: case USB_DESCR_TYP_STRING:
      0000AC 80 6C            [24]  746 	sjmp	00117$
      0000AE                        747 00104$:
                                    748 ;	src/usb_handler.c:73: switch(USB_setupBuf->wValueL) {      // String Descriptor Index
      0000AE 90 00 02         [24]  749 	mov	dptr,#(_EP0_buffer + 0x0002)
      0000B1 E0               [24]  750 	movx	a,@dptr
      0000B2 FE               [12]  751 	mov  r6,a
      0000B3 24 FB            [12]  752 	add	a,#0xff - 0x04
      0000B5 40 38            [24]  753 	jc	00110$
      0000B7 EE               [12]  754 	mov	a,r6
      0000B8 2E               [12]  755 	add	a,r6
                                    756 ;	src/usb_handler.c:74: case 0:   pDescr = USB_STR_DESCR_i0; break;
      0000B9 90r00rBD         [24]  757 	mov	dptr,#00385$
      0000BC 73               [24]  758 	jmp	@a+dptr
      0000BD                        759 00385$:
      0000BD 80 08            [24]  760 	sjmp	00105$
      0000BF 80 0E            [24]  761 	sjmp	00106$
      0000C1 80 14            [24]  762 	sjmp	00107$
      0000C3 80 1A            [24]  763 	sjmp	00108$
      0000C5 80 20            [24]  764 	sjmp	00109$
      0000C7                        765 00105$:
      0000C7 75*04r00         [24]  766 	mov	_pDescr,#_LangDescr
      0000CA 75*05s00         [24]  767 	mov	(_pDescr + 1),#(_LangDescr >> 8)
                                    768 ;	src/usb_handler.c:75: case 1:   pDescr = USB_STR_DESCR_i1; break;
      0000CD 80 26            [24]  769 	sjmp	00111$
      0000CF                        770 00106$:
      0000CF 75*04r00         [24]  771 	mov	_pDescr,#_ManufDescr
      0000D2 75*05s00         [24]  772 	mov	(_pDescr + 1),#(_ManufDescr >> 8)
                                    773 ;	src/usb_handler.c:76: case 2:   pDescr = USB_STR_DESCR_i2; break;
      0000D5 80 1E            [24]  774 	sjmp	00111$
      0000D7                        775 00107$:
      0000D7 75*04r00         [24]  776 	mov	_pDescr,#_ProdDescr
      0000DA 75*05s00         [24]  777 	mov	(_pDescr + 1),#(_ProdDescr >> 8)
                                    778 ;	src/usb_handler.c:77: case 3:   pDescr = USB_STR_DESCR_i3; break;
      0000DD 80 16            [24]  779 	sjmp	00111$
      0000DF                        780 00108$:
      0000DF 75*04r00         [24]  781 	mov	_pDescr,#_SerDescr
      0000E2 75*05s00         [24]  782 	mov	(_pDescr + 1),#(_SerDescr >> 8)
                                    783 ;	src/usb_handler.c:79: case 4:   pDescr = USB_STR_DESCR_i4; break;
      0000E5 80 0E            [24]  784 	sjmp	00111$
      0000E7                        785 00109$:
      0000E7 75*04r00         [24]  786 	mov	_pDescr,#_InterfDescr
      0000EA 75*05s00         [24]  787 	mov	(_pDescr + 1),#(_InterfDescr >> 8)
                                    788 ;	src/usb_handler.c:99: default:  pDescr = USB_STR_DESCR_ix; break;
      0000ED 80 06            [24]  789 	sjmp	00111$
      0000EF                        790 00110$:
      0000EF 75*04r00         [24]  791 	mov	_pDescr,#_SerDescr
      0000F2 75*05s00         [24]  792 	mov	(_pDescr + 1),#(_SerDescr >> 8)
                                    793 ;	src/usb_handler.c:100: }
      0000F5                        794 00111$:
                                    795 ;	src/usb_handler.c:101: len = pDescr[0];                    // descriptor length
      0000F5 85*04 82         [24]  796 	mov	dpl,_pDescr
      0000F8 85*05 83         [24]  797 	mov	dph,(_pDescr + 1)
      0000FB E4               [12]  798 	clr	a
      0000FC 93               [24]  799 	movc	a,@a+dptr
      0000FD FF               [12]  800 	mov	r7,a
                                    801 ;	src/usb_handler.c:102: break;
                                    802 ;	src/usb_handler.c:105: case USB_DESCR_TYP_REPORT:
      0000FE 80 1A            [24]  803 	sjmp	00117$
      000100                        804 00112$:
                                    805 ;	src/usb_handler.c:106: if(USB_setupBuf->wValueL == 0) {
      000100 90 00 02         [24]  806 	mov	dptr,#(_EP0_buffer + 0x0002)
      000103 E0               [24]  807 	movx	a,@dptr
      000104 70 0E            [24]  808 	jnz	00114$
                                    809 ;	src/usb_handler.c:107: pDescr = USB_REPORT_DESCR;
      000106 75*04r00         [24]  810 	mov	_pDescr,#_ReportDescr
      000109 75*05s00         [24]  811 	mov	(_pDescr + 1),#(_ReportDescr >> 8)
                                    812 ;	src/usb_handler.c:108: len = USB_REPORT_DESCR_LEN;
      00010C 90r00r00         [24]  813 	mov	dptr,#_ReportDescrLen
      00010F E4               [12]  814 	clr	a
      000110 93               [24]  815 	movc	a,@a+dptr
      000111 FF               [12]  816 	mov	r7,a
      000112 80 06            [24]  817 	sjmp	00117$
      000114                        818 00114$:
                                    819 ;	src/usb_handler.c:110: else len = 0xff;
      000114 7F FF            [12]  820 	mov	r7,#0xff
                                    821 ;	src/usb_handler.c:111: break;
                                    822 ;	src/usb_handler.c:114: default:
      000116 80 02            [24]  823 	sjmp	00117$
      000118                        824 00116$:
                                    825 ;	src/usb_handler.c:115: len = 0xff;                         // unsupported descriptors or error
      000118 7F FF            [12]  826 	mov	r7,#0xff
                                    827 ;	src/usb_handler.c:117: }
      00011A                        828 00117$:
                                    829 ;	src/usb_handler.c:119: if(len != 0xff) {
      00011A BF FF 03         [24]  830 	cjne	r7,#0xff,00387$
      00011D 02r02rA0         [24]  831 	ljmp	00174$
      000120                        832 00387$:
                                    833 ;	src/usb_handler.c:120: if(SetupLen > len) SetupLen = len;    // limit length
      000120 8F 05            [24]  834 	mov	ar5,r7
      000122 7E 00            [12]  835 	mov	r6,#0x00
      000124 C3               [12]  836 	clr	c
      000125 ED               [12]  837 	mov	a,r5
      000126 95*00            [12]  838 	subb	a,_SetupLen
      000128 EE               [12]  839 	mov	a,r6
      000129 95*01            [12]  840 	subb	a,(_SetupLen + 1)
      00012B 50 04            [24]  841 	jnc	00119$
      00012D 8D*00            [24]  842 	mov	_SetupLen,r5
      00012F 8E*01            [24]  843 	mov	(_SetupLen + 1),r6
      000131                        844 00119$:
                                    845 ;	src/usb_handler.c:121: len = SetupLen >= EP0_SIZE ? EP0_SIZE : SetupLen;
      000131 AD*00            [24]  846 	mov	r5,_SetupLen
      000133 AE*01            [24]  847 	mov	r6,(_SetupLen + 1)
      000135 C3               [12]  848 	clr	c
      000136 ED               [12]  849 	mov	a,r5
      000137 94 08            [12]  850 	subb	a,#0x08
      000139 EE               [12]  851 	mov	a,r6
      00013A 94 00            [12]  852 	subb	a,#0x00
      00013C 92*00            [24]  853 	mov	_USB_EP0_SETUP_sloc0_1_0,c
      00013E 40 04            [24]  854 	jc	00183$
      000140 7D 08            [12]  855 	mov	r5,#0x08
      000142 80 02            [24]  856 	sjmp	00184$
      000144                        857 00183$:
      000144 AD*00            [24]  858 	mov	r5,_SetupLen
      000146                        859 00184$:
      000146 8D 07            [24]  860 	mov	ar7,r5
                                    861 ;	src/usb_handler.c:122: USB_EP0_copyDescr(len);               // copy descriptor to Ep0
      000148 8F 82            [24]  862 	mov	dpl, r7
      00014A 12r00r00         [24]  863 	lcall	_USB_EP0_copyDescr
                                    864 ;	src/usb_handler.c:123: SetupLen -= len;
      00014D 8F 06            [24]  865 	mov	ar6,r7
      00014F AC*00            [24]  866 	mov	r4,_SetupLen
      000151 AD*01            [24]  867 	mov	r5,(_SetupLen + 1)
      000153 7B 00            [12]  868 	mov	r3,#0x00
      000155 EC               [12]  869 	mov	a,r4
      000156 C3               [12]  870 	clr	c
      000157 9E               [12]  871 	subb	a,r6
      000158 FC               [12]  872 	mov	r4,a
      000159 ED               [12]  873 	mov	a,r5
      00015A 9B               [12]  874 	subb	a,r3
      00015B FD               [12]  875 	mov	r5,a
      00015C 8C*00            [24]  876 	mov	_SetupLen,r4
      00015E 8D*01            [24]  877 	mov	(_SetupLen + 1),r5
                                    878 ;	src/usb_handler.c:124: pDescr += len;
      000160 EF               [12]  879 	mov	a,r7
      000161 25*04            [12]  880 	add	a, _pDescr
      000163 F5*04            [12]  881 	mov	_pDescr,a
      000165 E4               [12]  882 	clr	a
      000166 35*05            [12]  883 	addc	a, (_pDescr + 1)
      000168 F5*05            [12]  884 	mov	(_pDescr + 1),a
                                    885 ;	src/usb_handler.c:126: break;
      00016A 02r02rA0         [24]  886 	ljmp	00174$
                                    887 ;	src/usb_handler.c:128: case USB_SET_ADDRESS:
      00016D                        888 00122$:
                                    889 ;	src/usb_handler.c:129: SetupLen = USB_setupBuf->wValueL;        // save the assigned address
      00016D 90 00 02         [24]  890 	mov	dptr,#(_EP0_buffer + 0x0002)
      000170 E0               [24]  891 	movx	a,@dptr
      000171 F5*00            [12]  892 	mov	_SetupLen, a
      000173 75*01 00         [24]  893 	mov	(_SetupLen + 1),#0x00
                                    894 ;	src/usb_handler.c:130: break;
      000176 02r02rA0         [24]  895 	ljmp	00174$
                                    896 ;	src/usb_handler.c:132: case USB_GET_CONFIGURATION:
      000179                        897 00123$:
                                    898 ;	src/usb_handler.c:133: EP0_buffer[0] = UsbConfig;
      000179 90 00 00         [24]  899 	mov	dptr,#_EP0_buffer
      00017C E5*03            [12]  900 	mov	a,_UsbConfig
      00017E F0               [24]  901 	movx	@dptr,a
                                    902 ;	src/usb_handler.c:134: if (SetupLen >= 1) len = 1;
      00017F AD*00            [24]  903 	mov	r5,_SetupLen
      000181 AE*01            [24]  904 	mov	r6,(_SetupLen + 1)
      000183 C3               [12]  905 	clr	c
      000184 ED               [12]  906 	mov	a,r5
      000185 94 01            [12]  907 	subb	a,#0x01
      000187 EE               [12]  908 	mov	a,r6
      000188 94 00            [12]  909 	subb	a,#0x00
      00018A 50 03            [24]  910 	jnc	00390$
      00018C 02r02rA0         [24]  911 	ljmp	00174$
      00018F                        912 00390$:
      00018F 7F 01            [12]  913 	mov	r7,#0x01
                                    914 ;	src/usb_handler.c:135: break;
      000191 02r02rA0         [24]  915 	ljmp	00174$
                                    916 ;	src/usb_handler.c:137: case USB_SET_CONFIGURATION:
      000194                        917 00126$:
                                    918 ;	src/usb_handler.c:138: UsbConfig = USB_setupBuf->wValueL;
      000194 90 00 02         [24]  919 	mov	dptr,#(_EP0_buffer + 0x0002)
      000197 E0               [24]  920 	movx	a,@dptr
      000198 F5*03            [12]  921 	mov	_UsbConfig,a
                                    922 ;	src/usb_handler.c:139: break;
      00019A 02r02rA0         [24]  923 	ljmp	00174$
                                    924 ;	src/usb_handler.c:147: case USB_CLEAR_FEATURE:
      00019D                        925 00129$:
                                    926 ;	src/usb_handler.c:148: if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE ) {
      00019D 90 00 00         [24]  927 	mov	dptr,#_EP0_buffer
      0001A0 E0               [24]  928 	movx	a,@dptr
      0001A1 54 1F            [12]  929 	anl	a,#0x1f
      0001A3 70 2D            [24]  930 	jnz	00143$
                                    931 ;	src/usb_handler.c:149: if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x01 ) {
      0001A5 90 00 03         [24]  932 	mov	dptr,#(_EP0_buffer + 0x0003)
      0001A8 E0               [24]  933 	movx	a,@dptr
      0001A9 FD               [12]  934 	mov	r5,a
      0001AA 7E 00            [12]  935 	mov	r6,#0x00
      0001AC 90 00 02         [24]  936 	mov	dptr,#(_EP0_buffer + 0x0002)
      0001AF E0               [24]  937 	movx	a,@dptr
      0001B0 7B 00            [12]  938 	mov	r3,#0x00
      0001B2 42 06            [12]  939 	orl	ar6,a
      0001B4 EB               [12]  940 	mov	a,r3
      0001B5 42 05            [12]  941 	orl	ar5,a
      0001B7 BE 01 13         [24]  942 	cjne	r6,#0x01,00134$
      0001BA BD 00 10         [24]  943 	cjne	r5,#0x00,00134$
                                    944 ;	src/usb_handler.c:150: if( ((uint8_t*)&CfgDescr)[7] & 0x20) {
      0001BD 90r00r07         [24]  945 	mov	dptr,#(_CfgDescr + 0x0007)
      0001C0 E4               [12]  946 	clr	a
      0001C1 93               [24]  947 	movc	a,@a+dptr
      0001C2 30 E5 03         [24]  948 	jnb	acc.5,00395$
      0001C5 02r02rA0         [24]  949 	ljmp	00174$
      0001C8                        950 00395$:
                                    951 ;	src/usb_handler.c:153: else len = 0xFF;               // failed
      0001C8 7F FF            [12]  952 	mov	r7,#0xff
      0001CA 02r02rA0         [24]  953 	ljmp	00174$
      0001CD                        954 00134$:
                                    955 ;	src/usb_handler.c:155: else len = 0xFF;                 // failed
      0001CD 7F FF            [12]  956 	mov	r7,#0xff
      0001CF 02r02rA0         [24]  957 	ljmp	00174$
      0001D2                        958 00143$:
                                    959 ;	src/usb_handler.c:157: else if( (USB_setupBuf->bRequestType & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP ) {
      0001D2 90 00 00         [24]  960 	mov	dptr,#_EP0_buffer
      0001D5 E0               [24]  961 	movx	a,@dptr
      0001D6 FE               [12]  962 	mov	r6,a
      0001D7 53 06 1F         [24]  963 	anl	ar6,#0x1f
      0001DA BE 02 18         [24]  964 	cjne	r6,#0x02,00140$
                                    965 ;	src/usb_handler.c:158: switch(USB_setupBuf->wIndexL) {
      0001DD 90 00 04         [24]  966 	mov	dptr,#(_EP0_buffer + 0x0004)
      0001E0 E0               [24]  967 	movx	a,@dptr
      0001E1 FE               [12]  968 	mov	r6,a
      0001E2 BE 81 0B         [24]  969 	cjne	r6,#0x81,00137$
                                    970 ;	src/usb_handler.c:191: UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
      0001E5 74 BC            [12]  971 	mov	a,#0xbc
      0001E7 55 D2            [12]  972 	anl	a,_UEP1_CTRL
      0001E9 44 02            [12]  973 	orl	a,#0x02
      0001EB F5 D2            [12]  974 	mov	_UEP1_CTRL,a
                                    975 ;	src/usb_handler.c:192: break;
      0001ED 02r02rA0         [24]  976 	ljmp	00174$
                                    977 ;	src/usb_handler.c:199: default:
      0001F0                        978 00137$:
                                    979 ;	src/usb_handler.c:200: len = 0xFF;                 // unsupported endpoint
      0001F0 7F FF            [12]  980 	mov	r7,#0xff
                                    981 ;	src/usb_handler.c:202: }
      0001F2 02r02rA0         [24]  982 	ljmp	00174$
      0001F5                        983 00140$:
                                    984 ;	src/usb_handler.c:204: else len = 0xFF;                  // unsupported for non-endpoint
      0001F5 7F FF            [12]  985 	mov	r7,#0xff
                                    986 ;	src/usb_handler.c:205: break;
      0001F7 02r02rA0         [24]  987 	ljmp	00174$
                                    988 ;	src/usb_handler.c:207: case USB_SET_FEATURE:
      0001FA                        989 00145$:
                                    990 ;	src/usb_handler.c:208: if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE ) {
      0001FA 90 00 00         [24]  991 	mov	dptr,#_EP0_buffer
      0001FD E0               [24]  992 	movx	a,@dptr
      0001FE 54 1F            [12]  993 	anl	a,#0x1f
      000200 70 2B            [24]  994 	jnz	00161$
                                    995 ;	src/usb_handler.c:209: if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x01 ) {
      000202 90 00 03         [24]  996 	mov	dptr,#(_EP0_buffer + 0x0003)
      000205 E0               [24]  997 	movx	a,@dptr
      000206 FD               [12]  998 	mov	r5,a
      000207 7E 00            [12]  999 	mov	r6,#0x00
      000209 90 00 02         [24] 1000 	mov	dptr,#(_EP0_buffer + 0x0002)
      00020C E0               [24] 1001 	movx	a,@dptr
      00020D 7B 00            [12] 1002 	mov	r3,#0x00
      00020F 42 06            [12] 1003 	orl	ar6,a
      000211 EB               [12] 1004 	mov	a,r3
      000212 42 05            [12] 1005 	orl	ar5,a
      000214 BE 01 12         [24] 1006 	cjne	r6,#0x01,00149$
      000217 BD 00 0F         [24] 1007 	cjne	r5,#0x00,00149$
                                   1008 ;	src/usb_handler.c:210: if( !(((uint8_t*)&CfgDescr)[7] & 0x20) ) len = 0xFF;  // failed
      00021A 90r00r07         [24] 1009 	mov	dptr,#(_CfgDescr + 0x0007)
      00021D E4               [12] 1010 	clr	a
      00021E 93               [24] 1011 	movc	a,@a+dptr
      00021F 30 E5 03         [24] 1012 	jnb	acc.5,00404$
      000222 02r02rA0         [24] 1013 	ljmp	00174$
      000225                       1014 00404$:
      000225 7F FF            [12] 1015 	mov	r7,#0xff
      000227 80 77            [24] 1016 	sjmp	00174$
      000229                       1017 00149$:
                                   1018 ;	src/usb_handler.c:212: else len = 0xFF;                                        // failed
      000229 7F FF            [12] 1019 	mov	r7,#0xff
      00022B 80 73            [24] 1020 	sjmp	00174$
      00022D                       1021 00161$:
                                   1022 ;	src/usb_handler.c:214: else if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_ENDP ) {
      00022D 90 00 00         [24] 1023 	mov	dptr,#_EP0_buffer
      000230 E0               [24] 1024 	movx	a,@dptr
      000231 FE               [12] 1025 	mov	r6,a
      000232 53 06 1F         [24] 1026 	anl	ar6,#0x1f
      000235 BE 02 40         [24] 1027 	cjne	r6,#0x02,00158$
                                   1028 ;	src/usb_handler.c:215: if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x00 ) {
      000238 90 00 03         [24] 1029 	mov	dptr,#(_EP0_buffer + 0x0003)
      00023B E0               [24] 1030 	movx	a,@dptr
      00023C FD               [12] 1031 	mov	r5,a
      00023D 7E 00            [12] 1032 	mov	r6,#0x00
      00023F 90 00 02         [24] 1033 	mov	dptr,#(_EP0_buffer + 0x0002)
      000242 E0               [24] 1034 	movx	a,@dptr
      000243 7B 00            [12] 1035 	mov	r3,#0x00
      000245 42 06            [12] 1036 	orl	ar6,a
      000247 EB               [12] 1037 	mov	a,r3
      000248 42 05            [12] 1038 	orl	ar5,a
      00024A EE               [12] 1039 	mov	a,r6
      00024B 4D               [12] 1040 	orl	a,r5
      00024C 70 26            [24] 1041 	jnz	00155$
                                   1042 ;	src/usb_handler.c:216: switch( ( (uint16_t)USB_setupBuf->wIndexH << 8 ) | USB_setupBuf->wIndexL ) {
      00024E 90 00 05         [24] 1043 	mov	dptr,#(_EP0_buffer + 0x0005)
      000251 E0               [24] 1044 	movx	a,@dptr
      000252 FD               [12] 1045 	mov	r5,a
      000253 7E 00            [12] 1046 	mov	r6,#0x00
      000255 90 00 04         [24] 1047 	mov	dptr,#(_EP0_buffer + 0x0004)
      000258 E0               [24] 1048 	movx	a,@dptr
      000259 7B 00            [12] 1049 	mov	r3,#0x00
      00025B 42 06            [12] 1050 	orl	ar6,a
      00025D EB               [12] 1051 	mov	a,r3
      00025E 42 05            [12] 1052 	orl	ar5,a
      000260 BE 81 0D         [24] 1053 	cjne	r6,#0x81,00152$
      000263 BD 00 0A         [24] 1054 	cjne	r5,#0x00,00152$
                                   1055 ;	src/usb_handler.c:249: UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;// Set EP1 IN STALL 
      000266 74 BF            [12] 1056 	mov	a,#0xbf
      000268 55 D2            [12] 1057 	anl	a,_UEP1_CTRL
      00026A 44 03            [12] 1058 	orl	a,#0x03
      00026C F5 D2            [12] 1059 	mov	_UEP1_CTRL,a
                                   1060 ;	src/usb_handler.c:250: break;
                                   1061 ;	src/usb_handler.c:257: default:
      00026E 80 30            [24] 1062 	sjmp	00174$
      000270                       1063 00152$:
                                   1064 ;	src/usb_handler.c:258: len = 0xFF;               // failed
      000270 7F FF            [12] 1065 	mov	r7,#0xff
                                   1066 ;	src/usb_handler.c:260: }
      000272 80 2C            [24] 1067 	sjmp	00174$
      000274                       1068 00155$:
                                   1069 ;	src/usb_handler.c:262: else len = 0xFF;                // failed
      000274 7F FF            [12] 1070 	mov	r7,#0xff
      000276 80 28            [24] 1071 	sjmp	00174$
      000278                       1072 00158$:
                                   1073 ;	src/usb_handler.c:264: else len = 0xFF;                  // failed
      000278 7F FF            [12] 1074 	mov	r7,#0xff
                                   1075 ;	src/usb_handler.c:265: break;
                                   1076 ;	src/usb_handler.c:267: case USB_GET_STATUS:
      00027A 80 24            [24] 1077 	sjmp	00174$
      00027C                       1078 00163$:
                                   1079 ;	src/usb_handler.c:268: EP0_buffer[0] = 0x00;
      00027C 90 00 00         [24] 1080 	mov	dptr,#_EP0_buffer
      00027F E4               [12] 1081 	clr	a
      000280 F0               [24] 1082 	movx	@dptr,a
                                   1083 ;	src/usb_handler.c:269: EP0_buffer[1] = 0x00;
      000281 90 00 01         [24] 1084 	mov	dptr,#(_EP0_buffer + 0x0001)
      000284 F0               [24] 1085 	movx	@dptr,a
                                   1086 ;	src/usb_handler.c:270: if(SetupLen >= 2) len = 2;
      000285 AD*00            [24] 1087 	mov	r5,_SetupLen
      000287 AE*01            [24] 1088 	mov	r6,(_SetupLen + 1)
      000289 C3               [12] 1089 	clr	c
      00028A ED               [12] 1090 	mov	a,r5
      00028B 94 02            [12] 1091 	subb	a,#0x02
      00028D EE               [12] 1092 	mov	a,r6
      00028E 94 00            [12] 1093 	subb	a,#0x00
      000290 40 04            [24] 1094 	jc	00165$
      000292 7F 02            [12] 1095 	mov	r7,#0x02
      000294 80 0A            [24] 1096 	sjmp	00174$
      000296                       1097 00165$:
                                   1098 ;	src/usb_handler.c:271: else len = SetupLen;
      000296 AF*00            [24] 1099 	mov	r7,_SetupLen
                                   1100 ;	src/usb_handler.c:272: break;
                                   1101 ;	src/usb_handler.c:274: default:
      000298 80 06            [24] 1102 	sjmp	00174$
      00029A                       1103 00167$:
                                   1104 ;	src/usb_handler.c:275: len = 0xff;                       // failed
      00029A 7F FF            [12] 1105 	mov	r7,#0xff
                                   1106 ;	src/usb_handler.c:277: }
      00029C 80 02            [24] 1107 	sjmp	00174$
      00029E                       1108 00173$:
                                   1109 ;	src/usb_handler.c:280: else len = 0xff;                          // wrong packet length
      00029E 7F FF            [12] 1110 	mov	r7,#0xff
      0002A0                       1111 00174$:
                                   1112 ;	src/usb_handler.c:282: if(len == 0xff) {
      0002A0 BF FF 07         [24] 1113 	cjne	r7,#0xff,00179$
                                   1114 ;	src/usb_handler.c:283: SetupReq = 0xFF;
      0002A3 75*02 FF         [24] 1115 	mov	_SetupReq,#0xff
                                   1116 ;	src/usb_handler.c:284: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
      0002A6 75 DC CF         [24] 1117 	mov	_UEP0_CTRL,#0xcf
      0002A9 22               [24] 1118 	ret
      0002AA                       1119 00179$:
                                   1120 ;	src/usb_handler.c:286: else if(len <= EP0_SIZE) {      // Tx data to host or send 0-length packet
      0002AA EF               [12] 1121 	mov	a,r7
      0002AB 24 F7            [12] 1122 	add	a,#0xff - 0x08
      0002AD 40 06            [24] 1123 	jc	00176$
                                   1124 ;	src/usb_handler.c:287: UEP0_T_LEN = len;
      0002AF 8F DD            [24] 1125 	mov	_UEP0_T_LEN,r7
                                   1126 ;	src/usb_handler.c:288: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;// Expect DATA1, Answer ACK
      0002B1 75 DC C0         [24] 1127 	mov	_UEP0_CTRL,#0xc0
      0002B4 22               [24] 1128 	ret
      0002B5                       1129 00176$:
                                   1130 ;	src/usb_handler.c:291: UEP0_T_LEN = 0;  // Tx data to host or send 0-length packet
      0002B5 75 DD 00         [24] 1131 	mov	_UEP0_T_LEN,#0x00
                                   1132 ;	src/usb_handler.c:292: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;// Expect DATA1, Answer ACK
      0002B8 75 DC C0         [24] 1133 	mov	_UEP0_CTRL,#0xc0
                                   1134 ;	src/usb_handler.c:294: }
      0002BB 22               [24] 1135 	ret
                                   1136 ;------------------------------------------------------------
                                   1137 ;Allocation info for local variables in function 'USB_EP0_IN'
                                   1138 ;------------------------------------------------------------
                                   1139 ;len           Allocated to registers r6 
                                   1140 ;------------------------------------------------------------
                                   1141 ;	src/usb_handler.c:296: void USB_EP0_IN(void) {
                                   1142 ;	-----------------------------------------
                                   1143 ;	 function USB_EP0_IN
                                   1144 ;	-----------------------------------------
      0002BC                       1145 _USB_EP0_IN:
                                   1146 ;	src/usb_handler.c:298: switch(SetupReq) {
      0002BC 74 05            [12] 1147 	mov	a,#0x05
      0002BE B5*02 02         [24] 1148 	cjne	a,_SetupReq,00127$
      0002C1 80 42            [24] 1149 	sjmp	00102$
      0002C3                       1150 00127$:
      0002C3 74 06            [12] 1151 	mov	a,#0x06
      0002C5 B5*02 4B         [24] 1152 	cjne	a,_SetupReq,00103$
                                   1153 ;	src/usb_handler.c:301: len = SetupLen >= EP0_SIZE ? EP0_SIZE : SetupLen;
      0002C8 AE*00            [24] 1154 	mov	r6,_SetupLen
      0002CA AF*01            [24] 1155 	mov	r7,(_SetupLen + 1)
      0002CC C3               [12] 1156 	clr	c
      0002CD EE               [12] 1157 	mov	a,r6
      0002CE 94 08            [12] 1158 	subb	a,#0x08
      0002D0 EF               [12] 1159 	mov	a,r7
      0002D1 94 00            [12] 1160 	subb	a,#0x00
      0002D3 92*01            [24] 1161 	mov	_USB_EP0_IN_sloc0_1_0,c
      0002D5 40 04            [24] 1162 	jc	00107$
      0002D7 7E 08            [12] 1163 	mov	r6,#0x08
      0002D9 80 02            [24] 1164 	sjmp	00108$
      0002DB                       1165 00107$:
      0002DB AE*00            [24] 1166 	mov	r6,_SetupLen
      0002DD                       1167 00108$:
                                   1168 ;	src/usb_handler.c:302: USB_EP0_copyDescr(len);                     // copy descriptor to Ep0                                
      0002DD 8E 82            [24] 1169 	mov	dpl, r6
      0002DF 12r00r00         [24] 1170 	lcall	_USB_EP0_copyDescr
                                   1171 ;	src/usb_handler.c:303: SetupLen  -= len;
      0002E2 8E 07            [24] 1172 	mov	ar7,r6
      0002E4 AC*00            [24] 1173 	mov	r4,_SetupLen
      0002E6 AD*01            [24] 1174 	mov	r5,(_SetupLen + 1)
      0002E8 7B 00            [12] 1175 	mov	r3,#0x00
      0002EA EC               [12] 1176 	mov	a,r4
      0002EB C3               [12] 1177 	clr	c
      0002EC 9F               [12] 1178 	subb	a,r7
      0002ED FC               [12] 1179 	mov	r4,a
      0002EE ED               [12] 1180 	mov	a,r5
      0002EF 9B               [12] 1181 	subb	a,r3
      0002F0 FD               [12] 1182 	mov	r5,a
      0002F1 8C*00            [24] 1183 	mov	_SetupLen,r4
      0002F3 8D*01            [24] 1184 	mov	(_SetupLen + 1),r5
                                   1185 ;	src/usb_handler.c:304: pDescr    += len;
      0002F5 EE               [12] 1186 	mov	a,r6
      0002F6 25*04            [12] 1187 	add	a, _pDescr
      0002F8 F5*04            [12] 1188 	mov	_pDescr,a
      0002FA E4               [12] 1189 	clr	a
      0002FB 35*05            [12] 1190 	addc	a, (_pDescr + 1)
      0002FD F5*05            [12] 1191 	mov	(_pDescr + 1),a
                                   1192 ;	src/usb_handler.c:305: UEP0_T_LEN = len;
      0002FF 8E DD            [24] 1193 	mov	_UEP0_T_LEN,r6
                                   1194 ;	src/usb_handler.c:306: UEP0_CTRL ^= bUEP_T_TOG;                    // switch between DATA0 and DATA1
      000301 63 DC 40         [24] 1195 	xrl	_UEP0_CTRL,#0x40
                                   1196 ;	src/usb_handler.c:307: break;
                                   1197 ;	src/usb_handler.c:309: case USB_SET_ADDRESS:
      000304 22               [24] 1198 	ret
      000305                       1199 00102$:
                                   1200 ;	src/usb_handler.c:310: USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
      000305 E5 E3            [12] 1201 	mov	a,_USB_DEV_AD
      000307 54 80            [12] 1202 	anl	a,#0x80
      000309 FF               [12] 1203 	mov	r7,a
      00030A E5*00            [12] 1204 	mov	a,_SetupLen
      00030C 4F               [12] 1205 	orl	a,r7
      00030D F5 E3            [12] 1206 	mov	_USB_DEV_AD,a
                                   1207 ;	src/usb_handler.c:311: UEP0_CTRL  = UEP_R_RES_ACK | UEP_T_RES_NAK;
      00030F 75 DC 02         [24] 1208 	mov	_UEP0_CTRL,#0x02
                                   1209 ;	src/usb_handler.c:312: break;
                                   1210 ;	src/usb_handler.c:314: default:
      000312 22               [24] 1211 	ret
      000313                       1212 00103$:
                                   1213 ;	src/usb_handler.c:315: UEP0_T_LEN = 0;                             // end of transaction
      000313 75 DD 00         [24] 1214 	mov	_UEP0_T_LEN,#0x00
                                   1215 ;	src/usb_handler.c:316: UEP0_CTRL  = UEP_R_RES_ACK | UEP_T_RES_NAK;
      000316 75 DC 02         [24] 1216 	mov	_UEP0_CTRL,#0x02
                                   1217 ;	src/usb_handler.c:318: }
                                   1218 ;	src/usb_handler.c:319: }
      000319 22               [24] 1219 	ret
                                   1220 ;------------------------------------------------------------
                                   1221 ;Allocation info for local variables in function 'USB_EP0_OUT'
                                   1222 ;------------------------------------------------------------
                                   1223 ;	src/usb_handler.c:321: void USB_EP0_OUT(void) {
                                   1224 ;	-----------------------------------------
                                   1225 ;	 function USB_EP0_OUT
                                   1226 ;	-----------------------------------------
      00031A                       1227 _USB_EP0_OUT:
                                   1228 ;	src/usb_handler.c:322: UEP0_T_LEN = 0;
      00031A 75 DD 00         [24] 1229 	mov	_UEP0_T_LEN,#0x00
                                   1230 ;	src/usb_handler.c:323: UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_NAK;     // respond Nak
      00031D 43 DC 02         [24] 1231 	orl	_UEP0_CTRL,#0x02
                                   1232 ;	src/usb_handler.c:324: }
      000320 22               [24] 1233 	ret
                                   1234 ;------------------------------------------------------------
                                   1235 ;Allocation info for local variables in function 'USB_interrupt'
                                   1236 ;------------------------------------------------------------
                                   1237 ;callIndex     Allocated to registers r7 
                                   1238 ;------------------------------------------------------------
                                   1239 ;	src/usb_handler.c:332: void USB_interrupt(void) {   // inline not really working in multiple files in SDCC
                                   1240 ;	-----------------------------------------
                                   1241 ;	 function USB_interrupt
                                   1242 ;	-----------------------------------------
      000321                       1243 _USB_interrupt:
                                   1244 ;	src/usb_handler.c:333: if(UIF_TRANSFER) {
      000321 30 D9 42         [24] 1245 	jnb	_UIF_TRANSFER,00119$
                                   1246 ;	src/usb_handler.c:335: uint8_t callIndex = USB_INT_ST & MASK_UIS_ENDP;
      000324 E5 D9            [12] 1247 	mov	a,_USB_INT_ST
      000326 54 0F            [12] 1248 	anl	a,#0x0f
      000328 FF               [12] 1249 	mov	r7,a
                                   1250 ;	src/usb_handler.c:336: switch (USB_INT_ST & MASK_UIS_TOKEN) {
      000329 AE D9            [24] 1251 	mov	r6,_USB_INT_ST
      00032B 53 06 30         [24] 1252 	anl	ar6,#0x30
      00032E BE 00 02         [24] 1253 	cjne	r6,#0x00,00201$
      000331 80 0F            [24] 1254 	sjmp	00101$
      000333                       1255 00201$:
      000333 BE 10 02         [24] 1256 	cjne	r6,#0x10,00202$
      000336 80 2C            [24] 1257 	sjmp	00117$
      000338                       1258 00202$:
      000338 BE 20 02         [24] 1259 	cjne	r6,#0x20,00203$
      00033B 80 0D            [24] 1260 	sjmp	00108$
      00033D                       1261 00203$:
                                   1262 ;	src/usb_handler.c:337: case UIS_TOKEN_OUT:
      00033D BE 30 24         [24] 1263 	cjne	r6,#0x30,00117$
      000340 80 1C            [24] 1264 	sjmp	00113$
      000342                       1265 00101$:
                                   1266 ;	src/usb_handler.c:338: switch (callIndex) {
      000342 BF 00 1F         [24] 1267 	cjne	r7,#0x00,00117$
                                   1268 ;	src/usb_handler.c:339: case 0: EP0_OUT_callback(); break;
      000345 12r03r1A         [24] 1269 	lcall	_USB_EP0_OUT
                                   1270 ;	src/usb_handler.c:375: case UIS_TOKEN_IN:
      000348 80 1A            [24] 1271 	sjmp	00117$
      00034A                       1272 00108$:
                                   1273 ;	src/usb_handler.c:376: switch (callIndex) {
      00034A BF 00 02         [24] 1274 	cjne	r7,#0x00,00207$
      00034D 80 05            [24] 1275 	sjmp	00109$
      00034F                       1276 00207$:
                                   1277 ;	src/usb_handler.c:377: case 0: EP0_IN_callback(); break;
      00034F BF 01 12         [24] 1278 	cjne	r7,#0x01,00117$
      000352 80 05            [24] 1279 	sjmp	00110$
      000354                       1280 00109$:
      000354 12r02rBC         [24] 1281 	lcall	_USB_EP0_IN
                                   1282 ;	src/usb_handler.c:379: case 1: EP1_IN_callback(); break;
      000357 80 0B            [24] 1283 	sjmp	00117$
      000359                       1284 00110$:
      000359 12r00r00         [24] 1285 	lcall	_HID_EP1_IN
                                   1286 ;	src/usb_handler.c:393: case UIS_TOKEN_SETUP:
      00035C 80 06            [24] 1287 	sjmp	00117$
      00035E                       1288 00113$:
                                   1289 ;	src/usb_handler.c:394: switch (callIndex) {
      00035E BF 00 03         [24] 1290 	cjne	r7,#0x00,00117$
                                   1291 ;	src/usb_handler.c:395: case 0: EP0_SETUP_callback(); break;
      000361 12r00r1A         [24] 1292 	lcall	_USB_EP0_SETUP
                                   1293 ;	src/usb_handler.c:411: }
      000364                       1294 00117$:
                                   1295 ;	src/usb_handler.c:412: UIF_TRANSFER = 0;                       // clear interrupt flag
                                   1296 ;	assignBit
      000364 C2 D9            [12] 1297 	clr	_UIF_TRANSFER
      000366                       1298 00119$:
                                   1299 ;	src/usb_handler.c:416: if(UIF_BUS_RST) {
      000366 30 D8 0F         [24] 1300 	jnb	_UIF_BUS_RST,00121$
                                   1301 ;	src/usb_handler.c:417: UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
      000369 75 DC 02         [24] 1302 	mov	_UEP0_CTRL,#0x02
                                   1303 ;	src/usb_handler.c:420: USB_RESET_handler();                    // custom reset handler
      00036C 12r00r00         [24] 1304 	lcall	_HID_reset
                                   1305 ;	src/usb_handler.c:423: USB_DEV_AD   = 0x00;
      00036F 75 E3 00         [24] 1306 	mov	_USB_DEV_AD,#0x00
                                   1307 ;	src/usb_handler.c:424: UIF_SUSPEND  = 0;
                                   1308 ;	assignBit
      000372 C2 DA            [12] 1309 	clr	_UIF_SUSPEND
                                   1310 ;	src/usb_handler.c:425: UIF_TRANSFER = 0;
                                   1311 ;	assignBit
      000374 C2 D9            [12] 1312 	clr	_UIF_TRANSFER
                                   1313 ;	src/usb_handler.c:426: UIF_BUS_RST  = 0;                       // clear interrupt flag
                                   1314 ;	assignBit
      000376 C2 D8            [12] 1315 	clr	_UIF_BUS_RST
      000378                       1316 00121$:
                                   1317 ;	src/usb_handler.c:430: if (UIF_SUSPEND) {
                                   1318 ;	src/usb_handler.c:431: UIF_SUSPEND = 0;
                                   1319 ;	assignBit
      000378 10 DA 01         [24] 1320 	jbc	_UIF_SUSPEND,00212$
      00037B 22               [24] 1321 	ret
      00037C                       1322 00212$:
                                   1323 ;	src/usb_handler.c:432: if ( !(USB_MIS_ST & bUMS_SUSPEND) ) USB_INT_FG = 0xFF;  // clear interrupt flag
      00037C E5 DA            [12] 1324 	mov	a,_USB_MIS_ST
      00037E 20 E2 03         [24] 1325 	jb	acc.2,00126$
      000381 75 D8 FF         [24] 1326 	mov	_USB_INT_FG,#0xff
      000384                       1327 00126$:
                                   1328 ;	src/usb_handler.c:434: }
      000384 22               [24] 1329 	ret
                                   1330 ;------------------------------------------------------------
                                   1331 ;Allocation info for local variables in function 'USB_init'
                                   1332 ;------------------------------------------------------------
                                   1333 ;	src/usb_handler.c:441: void USB_init(void) {
                                   1334 ;	-----------------------------------------
                                   1335 ;	 function USB_init
                                   1336 ;	-----------------------------------------
      000385                       1337 _USB_init:
                                   1338 ;	src/usb_handler.c:444: | bUC_DMA_EN;                 // DMA enable
      000385 75 E2 29         [24] 1339 	mov	_USB_CTRL,#0x29
                                   1340 ;	src/usb_handler.c:446: | bUD_PORT_EN;                // Enable port, full-speed
      000388 75 D1 81         [24] 1341 	mov	_UDEV_CTRL,#0x81
                                   1342 ;	src/usb_handler.c:453: UEP0_DMA    = EP0_ADDR;                   // EP0 data transfer address
      00038B E4               [12] 1343 	clr	a
      00038C F5 EC            [12] 1344 	mov	((_UEP0_DMA >> 0) & 0xFF),a
      00038E F5 ED            [12] 1345 	mov	((_UEP0_DMA >> 8) & 0xFF),a
                                   1346 ;	src/usb_handler.c:455: | UEP_T_RES_NAK;              // EP0 IN transaction returns NAK
      000390 75 DC 02         [24] 1347 	mov	_UEP0_CTRL,#0x02
                                   1348 ;	src/usb_handler.c:458: USB_INIT_handler();                       // Custom EP init handler
      000393 12r00r00         [24] 1349 	lcall	_HID_setup
                                   1350 ;	src/usb_handler.c:463: | bUIE_BUS_RST;               // Enable device mode USB bus reset interrupt
      000396 43 E1 07         [24] 1351 	orl	_USB_INT_EN,#0x07
                                   1352 ;	src/usb_handler.c:465: USB_INT_FG |= 0x1F;                       // Clear interrupt flag
      000399 43 D8 1F         [24] 1353 	orl	_USB_INT_FG,#0x1f
                                   1354 ;	src/usb_handler.c:466: IE_USB      = 1;                          // Enable USB interrupt
                                   1355 ;	assignBit
      00039C D2 EA            [12] 1356 	setb	_IE_USB
                                   1357 ;	src/usb_handler.c:467: EA          = 1;                          // Enable global interrupts
                                   1358 ;	assignBit
      00039E D2 AF            [12] 1359 	setb	_EA
                                   1360 ;	src/usb_handler.c:469: UEP0_T_LEN  = 0;                          // Must be zero at start
      0003A0 75 DD 00         [24] 1361 	mov	_UEP0_T_LEN,#0x00
                                   1362 ;	src/usb_handler.c:470: }
      0003A3 22               [24] 1363 	ret
                                   1364 	.area CSEG    (CODE)
                                   1365 	.area CONST   (CODE)
                                   1366 	.area CABS    (ABS,CODE)
